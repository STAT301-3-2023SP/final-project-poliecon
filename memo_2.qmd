---
title: "Second Memo"
author: "Parth Patel & Qin Huang"

format:
  html:
    toc: true
    embed-resources: true
    code-fold: show
    link-external-newwindow: true
    
execute:
  warning: false
  echo: false

from: markdown+emoji 
---

::: {.callout-tip icon=false}

## Github Repo Link

[https://github.com/STAT301-3-2023SP/final-project-poliecon](https://github.com/STAT301-3-2023SP/final-project-poliecon)

:::

## Overview

### Prediction Problem

In this project, we use a survey dataset of American youths to predict whether a specific interviewee voted or not in the 2012 presidential election based on their demographics, experiences with civic education, family and friend influences, and their political values. Therefore, it is a classification problem.

### Modeling Plan

In this memo, we developed a well-working recipe. The comprehensive recipe has six steps: 'step_string2factor' is used to convert character variables to factors; ' step_dummy' is used to convert factor variables into a series of binary (0 and 1) variables; ' step_center' xis used to center variables, which means subtracting the mean of a variable from all its values;  'step_scale' is used to scale variables, which means dividing all the values of a variable by its standard deviation. 

This basic recipe also removes variables with over 20% missing values and uses knn for imputation through 'step_rm' and 'step_impute_knn'. It also involves two more steps: 'step_other' is used to collapse infrequent factor levels into a single "other" level; 'step_nzv' is used to identify and remove predictors that have near-zero variance. 

In our final analysis, we might try to develop a second recipe by using step_impute_bass to replace knn imputation and see whether this new imputation method works better than the original one. 

To evaluate the final model, roc_auc will be used as the main comparison metric.

All codes for this memo can be found within memo_2_code.R and the respective modeling R scripts.

### Current Model Results & Runtimes

For this memo, the one recipe was used with a random forest model and a null model. The random forest model mtry, min_n, and trees hyperparameters were tuned.

The results can be found below.

```{r}
 #| warning: false

library(tidyverse)
library(tidymodels)
library(gt)

load("results/null.rda")
load("results/null_2.rda")
load("results/boosted_tree_2.rda")
load("results/boosted_tree.rda")
load("results/elastic_net_2.rda")
load("results/elastic_net.rda")
load("results/knn_2.rda")
load("results/knn.rda")
load("results/mars_2.rda")
load("results/mars.rda")
load("results/rf_2.rda")
load("results/rf.rda")
load("results/slnn_mlp_2.rda")
load("results/slnn_mlp.rda")
load("results/svm_poly_2.rda")
load("results/svm_poly.rda")
load("results/svm_radial.rda")
load("results/svm_radial_2.rda")

mars_2_time <- mars_tictoc_2 %>% 
  filter(model == "MARS Recipe 2")

mars_time <- mars_tictoc %>% 
  filter(model == "MARS")

nn_2_time <- nn_tictoc_2 %>% 
  filter(model == "Single Layer Neural Network Recipe 2")

nn_time <- nn_tictoc %>% 
  filter(model == "Single Layer Neural Network")

svm_poly_2_time <- svm_poly_tictoc_2 %>% 
  filter(model == "SVM Polynomial Recipe 2")

svm_poly_time <- svm_poly_tictoc %>% 
  filter(model == "SVM Polynomial")

svm_rad_2_time <- svm_radial_tictoc_2 %>% 
  filter(model == "SVM Radial Recipe 2")

svm_rad_time <- svm_radial_tictoc %>% 
  filter(model == "SVM Radial")

bt_2_time <- bt_tictoc_2 %>% 
  filter(model == "Boosted Tree Recipe 2")

bt_time <- bt_tictoc %>% 
  filter(model == "Boosted Tree")

knn_2_time <- kn_tictoc_2 %>% 
  filter(model == "K-Nearest Neighbor Recipe 2")

knn_time <- kn_tictoc %>% 
  filter(model == "K-Nearest Neighbor")

en_2_time <- en_tictoc_2 %>% 
  filter(model == "Elastic Net Recipe 2")

en_time <- en_tictoc %>% 
  filter(model == "Elastic Net")

rf_2_time <- rf_tictoc_2 %>% 
  filter(model == "Random Forest Recipe 2")

rf_time <- rf_tictoc %>% 
  filter(model == "Random Forest")

null_2_time <- null_tictoc_2 %>% 
  filter(model == "Null Model Recipe 2")

null_time <- null_tictoc %>% 
  filter(model == "Null Model")

time_tib <- purrr::reduce(list(null_time, null_2_time, rf_time, rf_2_time, en_time, en_2_time, bt_time, bt_2_time, knn_time, knn_2_time, svm_rad_time, svm_rad_2_time, svm_poly_time, svm_poly_2_time, nn_time, nn_2_time, mars_time, mars_2_time), dplyr::full_join) 
  # gt() %>% 
  # tab_header(title = md("**Model Runtime**"))

model_set <- 
  as_workflow_set(
    "mars recipe 2" = mars_tuned_2,
    "mars" = mars_tuned,
    "single layer neural network recipe 2" = nn_tuned_2,
    "single layer neural network" = nn_tuned,
    "svm poly recipe 2" = svm_poly_tuned_2,
    "svm poly" = svm_poly_tuned,
    "svm rad recipe 2" = svm_radial_tuned_2,
    "svm rad" = svm_radial_tuned,
    "bt recipe 2" = bt_tuned_2,
    "bt" = bt_tuned,
    "knn recipe 2" = kn_tuned_2,
    "knn" = kn_tuned,
    "elastic net recipe 2" = en_tuned_2,
    "elastic net" = en_tuned,
    "rf recipe 2" = rf_tuned_2,
    "rf" = rf_tuned,
    "null recipe 2" = null_tuned_2,
    "null" = null_tuned
  )

best_models <- as_tibble(
  rank_results(model_set, rank_metric = "roc_auc", select_best = TRUE) %>% 
  filter(.metric == "roc_auc") %>% 
  select(wflow_id, mean, rank)
)

# ranked_mods <- gt(best_models) %>% 
#   cols_label(wflow_id = html("Model Type"),
#              mean = html("Mean"),
#              rank = html("Rank")
#   ) %>% 
#   tab_header(
#     title = md("**Top Ranked Models**"),
#     subtitle = "Metric = ROC-AUC"
#   )

save(time_tib, best_models, file = "final_results/final_tables.rda")

save(model_set, file = "results/model_set.rda")
```

### Relevant Challenges

The random forest model took half an hour to fit and thus we imagine that it might take longer time to fit an XGBoost model. We will see whether fitting an XGBoost model is manageable. 

Meanwhile, if it is super quick to fit other models that are less computationally expensive, such as regression and knn, we would consider incorporating a few more variables into our models, hoping to build a better-performed model. 